#!/bin/env python
# -*- coding: utf-8 -*-
# ####################################################################
# Copyright (C) 2016  Fridolin Pokorny, fpokorny@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
# ####################################################################


import ast
import codegen
import graphviz
import logging
import os
from version import nodenator_version
from dill.source import getsource
from template import should_process, validate_input, validate_output
from utils.helpers import dict2json
from node import Node
from edge import Edge
from predicate import Predicate
from config import Config


_SRC_PREAMBLE = "#!/bin/env python\n# Autogenerated using nodegenerator %s\n\n" % nodenator_version


class System(object):
    """
    Representation of the whole system
    """
    def __init__(self, nodes=None, edges=None, raw_defs=None):
        """
        Init
        :param nodes: system nodes
        :type nodes: [Node]
        :param edges: system edges
        :type edges: [Edge]
        :param raw_defs: raw system definition
        :type raw_defs: dict
        """
        self._nodes = nodes if nodes is not None else []
        self._edges = edges if edges is not None else []
        self._raw_defs = raw_defs

    @staticmethod
    def construct(defs):
        """
        Construct system based on definitions
        :param defs: definitions to be used
        :return: constructed system representation
        :type: System
        """
        system = System(raw_defs=defs)
        for n in defs['nodes']:
            if 'name' not in n:
                raise ValueError('Node name is mandatory in:\n%s' % dict2json(n))

            input_conditions = Predicate.construct(n['input']) if n.get('input') else None
            output_conditions = Predicate.construct(n['output']) if n.get('output') else None

            node = Node(n['name'], input_condition=input_conditions, output_condition=output_conditions,
                        description=n.get('desc'), srcpath = n.get('srcpath'),
                        dump_node_comparison=n.get('dump-node-comparison'))
            system.add_node(node)

        for e in defs['edges']:
            if 'to' not in e or 'from' not in e:
                raise ValueError("Edge definition has to provide at least from and 'to':'\n%s" % dict2json(e))
            if 'condition' not in e:
                raise ValueError("Edge definition has to provide condition:\n%s" % dict2json(e))
            condition = Predicate.construct(e['condition'])
            node_to = system.node_by_name(e['to'])
            node_from = system.node_by_name(e['from'])
            edge = Edge(name=e.get('name'), node_to=node_to, condition=condition,
                        node_from=node_from, description=e.get('description'))
            system.add_edge(edge)
            node_to.add_input_edge(edge)
            node_from.add_output_edge(edge)

        return system

    def plot_graph(self, output_file):
        """
        Plot system representation
        :param output_file: output file
        :type output_file: str
        :return: output file
        :rtype: str
        """
        graph = graphviz.Digraph(format=output_file.split('.')[-1])
        graph.graph_attr.update(Config().style_graph())
        graph.node_attr.update(Config().style_node())
        graph.edge_attr.update(Config().style_edge())

        for node in self._nodes:
            graph.node(name=node.name(), label=node.description())

        for edge in self._edges:
            graph.edge(tail_name=edge.node_from().name(), head_name=edge.node_to().name(),
                       label="%s: %s" % (edge.name(), str(edge.condition())))

        graph.render(cleanup=True, filename=".".join(output_file.split('.')[:-1]))
        logging.info("Graph rendered to '%s'" % output_file)

        return output_file

    def check(self):
        """
        Check system
        :return: True if all tests passed
        :rtype: bool
        """
        ret = True

        # Currently there is no need to implement more sophisticated tests,
        # BUT keep in mind that this problem is SMT problem - a SMT solver needs to be implemented
        for node in self._nodes:
            if len(node.output_edges()) == 0:
                if len(node.input_edges()) == 0:
                    logging.warning("Node '%s' has no input nor output edge!" % node.name())
                    ret = False
                else:
                    logging.warning("Node '%s' has no output edge!" % node.name())
                    ret = False
            elif len(node.input_edges()) == 0:
                logging.warning("Node '%s' has no input edge!" % node.name())
                ret = False
        logging.info("Checks finished")

        return ret

    def dump(self):
        """
        Dump system to source files
        :return: None
        """
        def set_condition(ast_func, condition):
            # we have to skip Module first - add to function body
            stm = ast.Return(value=condition)
            # let's replace the original Return with new statement
            ast_func.body[0].body[0] = stm

        def append_condition_process(ast_func, condition, node_from):
            # we have to skip Module first - add to function body
            if_stm = ast.If(test=condition, body=[ast.Return(value=ast.Name(id='True', ctx=ast.Load()))], orelse=[])
            # leave the last return, which will be transformed to return False
            ast_func.body[0].body.insert(-2, node_from.ast_comparison(if_stm))

        def fix_return(ast_func):
            # we have to return False if no condition succeeded
            if len(ast_func.body[0].body) > 1:
                ast_func.body[0].body[-1] = ast.Return(value=ast.Name(id='False', ctx=ast.Load()))

        # get rid of circular dependencies
        visited = {}
        for node in self._nodes:
            if visited.get(node, False):
                continue

            visited[node] = True
            # do not print a predicate more than once
            printed_predicates = {}

            logging.info("Performing dump for node '%s' to '%s'" % (node.name(), node.srcpath()))

            ast_validate_input = ast.parse(getsource(validate_input))
            ast_validate_output = ast.parse(getsource(validate_output))
            ast_should_process = ast.parse(getsource(should_process))

            if node.srcpath() is None:
                raise ValueError("No source path specified for node '%s'" % node.name())

            with open(node.srcpath(), "w") as f:
                f.write(_SRC_PREAMBLE)

                # generate import for all nodes that are specified by instance
                for edge in node.input_edges():
                    node_from = edge.node_from()
                    if node_from.dump_node_comparison_instance():
                        f.write('from %s import %s\n' % (node_from.dump_node_comparison_instance(), node_from.name()))
                f.write('\n\n')

                # print predicates used in output conditions
                if node.output_condition():
                    for predicate in node.output_condition().predicates_used():
                        if not printed_predicates.get(predicate):
                            f.write(getsource(predicate))
                            printed_predicates[predicate] = True
                            f.write('\n\n')

                # print predicates used input conditions
                if node.input_condition():
                    for predicate in node.input_condition().predicates_used():
                        if not printed_predicates.get(predicate):
                            f.write(getsource(predicate))
                            printed_predicates[predicate] = True
                            f.write('\n\n')

                # print predicates used in edge conditions
                for edge in node.input_edges():
                    for predicate in edge.condition().predicates_used():
                        if not printed_predicates.get(predicate):
                            f.write(getsource(predicate))
                            printed_predicates[predicate] = True
                            f.write('\n\n')

                    append_condition_process(ast_should_process, edge.condition().ast(), edge.node_from())

                if node.output_condition():
                    set_condition(ast_validate_output, node.output_condition().ast())
                    fix_return(ast_validate_output)

                if node.input_condition():
                    set_condition(ast_validate_input, node.input_condition().ast())
                    fix_return(ast_validate_input)

                f.write('#'*80 + '\n\n')
                f.write(codegen.to_source(ast_validate_input))
                f.write('\n\n\n')
                f.write(codegen.to_source(ast_validate_output))
                f.write('\n\n\n')
                fix_return(ast_should_process)
                f.write(codegen.to_source(ast_should_process))
                f.write('\n\n\n')

    @staticmethod
    def evaluate(message):
        """
        Simulate a message generation
        :param message: Message
        :return: list of nodes that accepted node
        :rtype: list(Node)
        """
        ret = []

        logging.info("Message from node '%s'" % message.node_from().name())

        for edge in message.node_from().output_edges():
            logging.info("Message to node '%s'" % edge.node_to().name())
            logging.info("Condition: %s" % str(edge.condition()))
            if edge.condition().evaluate(message.message()):
                logging.info("Node '%s' accepted message" % edge.node_to().name())
                ret.append(edge.node_to())
            else:
                logging.info("Node '%s' rejected message" % edge.node_to().name())

        return ret

    @staticmethod
    def check_node_input(message):
        """
        Check node input
        :param message: a message that is going to be processed
        :type message: Message
        :return: True if message is a correct input message
        :rtype: bool
        """
        # TODO: make a list of recepients here
        if not message.node_to():
            raise ValueError("No receiving node specified")
        logging.info("Checking input message for node '%s'" % message.node_to().name())
        if not message.node_to().input_condition():
            raise ValueError("No input condition defined for node '%s'" % message.node_to().name())
        if message.node_to().input_condition().evaluate(message.message()):
            logging.info("Input message is correct")
            return True
        else:
            logging.warning("Input message is not correct")
            return False

    @staticmethod
    def check_node_output(message):
        """
        Check node output
        :param message: a message that was computed
        :type message: Message
        :return: True if message is a correct output message
        :rtype: bool
        """
        logging.info("Checking output message for node '%s'" % message.node_from().name())
        if not message.node_from().output_condition():
            raise ValueError("No output condition defined for node '%s'" % message.node_from().name())
        if message.node_from().output_condition().evaluate(message.message()):
            logging.info("Input message is correct")
            return True
        else:
            logging.warning("Input message is not correct")
            return False

    def nodes(self):
        """
        Return all nodes stored in the system
        :return: nodes stored in the system
        :rtype: list(Node)
        """
        return self._nodes

    def edges(self):
        """
        Return all edges stored in the system
        :return: edges stored in the system
        :rtype: list(Edge)
        """
        return self._edges

    def add_node(self, node):
        """
        Add a node to the system
        :param node: a node to be added
        :type node: Node
        :return: None
        """
        self._nodes.append(node)

    def add_edge(self, edge):
        """
        Add an edge to the system
        :param edge: an edge to be added
        :type edge: Edge
        :return: None
        """
        self._edges.append(edge)

    def node_by_name(self, name):
        """
        Find a node by its name
        :param name: name of a node
        :type name: str
        :return: Node with given name
        :rtype: Node
        :raises ValueError: if node with given name is not found
        """
        for node in self._nodes:
            if node.name() == name:
                return node
        raise ValueError("Node with name '%s' not found" % name)

    def raw_defs(self):
        """
        Get raw definition as parsed received in construct() method
        :return: raw definition
        :rtype: dict
        """
        return self._raw_defs
